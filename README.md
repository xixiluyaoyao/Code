# 队列

![image-20250207211055864](https://cdn.jsdelivr.net/gh/xixiluyaoyao/Code@master/202502072110049.png)

![image-20250207212228390](https://cdn.jsdelivr.net/gh/xixiluyaoyao/Code@master/202502072122673.png)

- 传入用*q而不是用q：

```
void initQueue(Queue *q)
```

在C语言中，函数参数传递默认是**按值传递**（pass by value），这意味着如果你直接传递一个结构体（如 `Queue q`），函数会创建该结构体的一个副本。对于较大的结构体，复制数据会浪费时间和内存。

通过传递指针（如 `Queue *q`），函数只需要复制指针的值（即内存地址），而不是整个结构体。这样可以显著提高性能。

- 循环队列：

  假设队列的容量是 5 (`MAX_SIZE = 5`)，队列元素的索引范围是 0 到 4。

  - 初始时，`q->front = 0`（队列的前端指针指向第一个元素）。

  - 当执行 

    ```
    q->front = (q->front + 1) % 5;
    ```

     时：

    - 如果 `q->front` 是 0，执行 `q->front = (0 + 1) % 5 = 1`，前端指针向后移动一位。
    - 如果 `q->front` 是 1，执行 `q->front = (1 + 1) % 5 = 2`，前端指针继续向后移动一位。
    - 如果 `q->front` 是 4，执行 `q->front = (4 + 1) % 5 = 0`，前端指针将回到队列的起始位置，实现了循环。

- 循环的作用：

  ### **避免浪费空间**：

  在一个普通的线性队列（非循环队列）中，当队列的元素被删除（出队）时，前面的空间不会被重新利用。这意味着，即使有空闲位置可以插入新的元素，队列的实现可能依然认为队列已满，从而导致浪费。

  例如，如果队列的大小是 `MAX_SIZE`，并且元素被出队后，队列的**头部**变得空闲，但是队列的尾部可能已满。这样，尽管队列有空间，但仍然不能继续插入新元素。

  #### 普

  #### 通队列的情况：

  ```
  rust复制编辑队列 [1, 2, 3, 4]    => front -> 0, rear -> 4
  出队操作，元素 1 被删除
  队列 [_, 2, 3, 4]    => front -> 1, rear -> 4
  ```

  - 这里 `front` 指向位置 1，`rear` 仍指向位置 4。虽然位置 0 已经空了，但是在普通队列的实现中，这个位置无法再使用了。

  ### **循环队列解决这个问题**：

  循环队列通过“循环”特性解决了空间浪费的问题。它的思想是：当队列的尾部指针（`rear`）到达数组的末尾时，如果头部有空位，就可以继续从头部插入新元素，**而不是停在数组的末尾**。

  #### 循环队列的优势：

  - **空间利用最大化**：它确保队列中所有空闲的位置都能被有效利用。即使队列的前端已经出队，尾部指针依然可以重新从前面开始插入新的元素。
  - **避免数组空间浪费**：队列中可能有已出队的位置，但是仍然可以在这些空位上插入新元素，而不需要移动已有的元素。

  #### 举个例子：

  ```
  rust复制编辑队列 [1, 2, 3, 4]   => front -> 0, rear -> 4
  出队操作，元素 1 被删除
  队列 [_, 2, 3, 4]   => front -> 1, rear -> 4
  入队操作，元素 5 被插入
  队列 [5, 2, 3, 4]   => front -> 1, rear -> 0  (rear 回到头部)
  ```

  - 通过“循环”特性，尾指针（`rear`）已经从 `MAX_SIZE-1`（队列末尾）回到了队列的头部位置 `0`，重新利用了先前出队后的空位。

- 打印函数：

  ```
  void printQueue(Queue* p) {
      if (isEmpty(p)) {
          printf("队列为空！\n");
          return;
      }
      int i = p->front;
      int cnt = 0;
  while (cnt < q->size) {
      printf("%d ", q->items[i]);  // 打印当前位置的元素
      i = (i + 1) % MAX_SIZE;      // 移动到下一个位置，使用模运算实现循环
      count++;                      // 更新计数器
  }
  ```

  在循环队列中，队尾指针可能在队头指针的前面，这时候引入`i=p->front`;`i = (i + 1) % MAX_SIZE;`如果 `i` 增加到 `MAX_SIZE`，就会回到 `0`，从而实现**循环**访问。而计数器`cnt`的作用是：每打印一个元素，`cnt` 就增加 1，直到 `cnt == q->size`，即队列中的所有元素都被打印出来。这样，即使队尾指针在队头指针前面，`i`也能随着循环在走到数组的最后一个元素后重新回到数组的起点并继续移动下去，直到打印出所有元素`(cnt==q->size)`

  

